## Build

Assume you've cloned the vcpkg repository to `A/vcpkg/`. If you are on Windows system, run `A/vcpkg/bootstrap-vcpkg.exe`. On Linux, run `A/vcpkg/bootstrap-vcpkg.sh`. This installs vcpkg. After installing, add `A/vcpkg` to PATH. Run `vcpkg integrate install`.

Run `cmake -S {repo path} -B {build path} -DCMAKE_TOOLCHAIN_FILE={vcpkg path}/scripts/buildsystems/vcpkg.cmake`. If you are not sure where to run the command in Visual Studio, run this using windows powershell, then Visual Studio will do the same if you open this folder with it. 

If cmake still doesn't download the packages and returns an error, maybe Visual Studio is using an incomplete cmake, or the environment variables aren't right. The worst alternative is downloading those libraries by hand, using `vcpkg install` under the repository. You may need to add a bunch of other environment variables. I did this during the first attempt. Here is a warning from the TA:

` You should add path vcpkg_installed/ into .gitignore if you want to install packages with the command and avoid adding installed binary files into your commited repo. Actually, by applying -DCMAKE_TOOLCHAIN_FILE=* parameter, vcpkg will automatically do installation during CMake configuration stage. Uploading compiled binary files should always be considered ILLEGAL!`

On Linux , a possible error (which occurred on my wsl when I'm downloading by hand) is
```bash
Target "freetype" links to:

    ZLIB::ZLIB

but the target was not found. Possible reasons include:

    * There is a typo in the target name.
    * A find_package call is missing for an IMPORTED target.
    * An ALIAS target is missing.
```
This corresponds to an error in `freetype-config.cmake` just downloaded, which then results from the following lines in `freetype-targets.cmake`:
```bash
add_library(freetype STATIC IMPORTED)

set_target_properties(free type PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
    INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ZLIB::ZLIB>; ... "
)
```
Adding `find_package(ZLIB REQUIRED)` into the blank line in the middle seems to solve this problem.

## The app

### Running the game

In this section, we will analyse this whole project without caring about the external libraries. We begin with the file
```c++
(battle_game/battle_game.cpp)

int main() {
  battle_game::GameCore game_core;
  battle_game::AppSettings app_settings;
  battle_game::App app(app_settings, &game_core);
  app.Run();
}
```
Every `battle_game::App` object contains a `battle_game::GameCore` pointer, which is set to `game_core` in the constructor. We don't need to care about `battle_game::AppSettings`. Then the central part is the `Run()` function:
```c++
void App::Run() {
  OnInit();

  while (!glfwWindowShouldClose(core_->GetWindow())) {
    OnLoop();
    glfwPollEvents();
  }

  core_->GetDevice()->WaitIdle();

  OnClose();
}
```

The `OnInit()` function initializes the very basic settings of the game. Inside its implementation, `SyncDeviceAssets()` makes sure that every object in the game is properly output to the screen; `SetScene()` sets the players of the game:
```c++
void App::SetScene() {
  my_player_id_ = game_core_->AddPlayer();
  auto enemy_player_id = game_core_->AddPlayer();
  game_core_->SetRenderPerspective(my_player_id_);
}
```
The function `SetRenderPerspective` sets the window at your perspective, not other's. Note that the default enemy is a real player (with nonzero id) but you can't control him.


The next part of `Run()` basically reads
```c++
while (window is not closed) {
  update the objects;
  use external libraries to output the possible events;
}

close the window and exit the game;
```
Hence it is the updating part `OnLoop()` we should care about. It can then be divide into two parts: `OnUpdate()` and `OnRender()`. The function `OnRender()` deals with the graphics, so let's look at `OnUpdate()`:
```c++
void App::OnUpdate() {
  UpdateImGui();
  NewFrame();
  CaptureInput();
  UpdateDrawCommands();
  UpdateDynamicBuffer();

  auto mgr = AssetsManager::GetInstance();
  if (!mgr->GetSyncState()) {
    SyncDeviceAssets();
  }
}
```
The function `CaptureInput()` reads the input from the keyboard, and the `UpdateDrawCommands()` function updates `game_core_`:
```c++
void App::UpdateDrawCommands() {
  ...
  while (updated_step < target_update_step) {
    game_core_->Update();
    updated_step++;
  }
  game_core_->Render();
}
```
The `Update()` function of `game_core_` updates all the objects. If you want to implement new objects, you should at least declare how they update (in one tick) and how they are rendered.

### GameCore

Every player shares one game core, the one declared in `battle_game.cpp`. Creating a unit is done by `GameCore::AllocatePrimaryUnit(uint32_t player_id)`, and bullets are generated by `Unit::GenerateBullet()`. `game_core_` has member variables 
```c++
class GameCore{
  ...
  private:
  ...
  std::map<uint32_t, std::unique_ptr<Unit>> units_;
  uint32_t unit_index_{1};
  std::map<uint32_t, std::unique_ptr<Bullet>> bullets_;
  uint32_t bullet_index_{1};
  std::map<uint32_t, std::unique_ptr<Particle>> particles_;
  uint32_t particle_index_{1};
  std::map<uint32_t, std::unique_ptr<Obstacle>> obstacles_;
  uint32_t obstacle_index_{1};
  std::map<uint32_t, std::unique_ptr<Player>> players_;
  uint32_t player_index_{1};
}
```
mapping the player's id to his units, bullets, particles, obstacles, players. The constructor of `GameCore` reads 
```c++
GameCore::GameCore() {
  auto mgr = AssetsManager::GetInstance();
  boundary_model_ = mgr->RegisterModel(
      std::vector<ObjectVertex>{
          {{-1.0f, 1.0f}, {0.0f, 0.0f}, {1.0f, 0.0f, 0.0f, 1.0f}},
          {{1.0f, 1.0f}, {0.0f, 0.0f}, {1.0f, 0.0f, 0.0f, 1.0f}},
          {{-1.0f, -1.0f}, {0.0f, 0.0f}, {1.0f, 0.0f, 0.0f, 0.0f}},
          {{1.0f, -1.0f}, {0.0f, 0.0f}, {1.0f, 0.0f, 0.0f, 0.0f}}},
      std::vector<uint32_t>{0, 1, 2, 1, 2, 3});
  SetScene();
  GeneratePrimaryUnitList();
}
```
Here `mgr` is an `AssetsManager`, which helps manage the models and textures; the `GetInstance()` function will return the same instance of `AssetsManager` whenever it's called, because the return value is declared `static`. The reader is encouraged to change some of the numbers inside `RegisterModel` and see what happens. The `GetPrimaryUnitList()` function enables you to choose among the units. The `SetScene()` function reads
```c++
void GameCore::SetScene() {
  AddObstacle<obstacle::Block>(glm::vec2{-3.0f, 4.0f});
  respawn_points_.emplace_back(glm::vec2{0.0f}, 0.0f);
  respawn_points_.emplace_back(glm::vec2{3.0f, 4.0f}, glm::radians(90.0f));
  boundary_low_ = {-10.0f, -10.0f};
  boundary_high_ = {10.0f, 10.0f};
}
```
It is responsible for the black square obstacle in the game. It also sets the two default respawn points `(0,0)` and `(3,4)` with 90 rotation. After a unit dies, it will reappear in one of the locations in `spawn_points_` randomly. 

One might notice that every time you open the game, your tank and the default enemy's tank are always at the same spot. This is because the `RandomInt(0, 1)` function's first two outputs are always the same, corresponding to these two locations. If you want them to differ, the list should have at least 16 elements. Also, the numbers generated by the random device `std::mt19937 random_device_{0}` are pseudorandom, so in theory you can know all about it. Things like the smoke when the cannon ball hits a unit also uses a random function, so any attempt to memorize those pseudorandom numbers must take those into account.

In `GameCore` there are also a lot of 'events'. Their names infer what they are.

### InputData

The `InputData` struct is implemented as follows: 
```c++
struct InputData {
  bool key_down[kKeyRange]{};
  bool mouse_button_down[kMouseButtonRange]{};
  bool mouse_button_clicked[kMouseButtonRange]{};
  glm::vec2 mouse_cursor_position{0.0f};
};
```
As their names suggest, it uses an array `key_down` to store which keys are pressed, and a 2d vector to represent the cursor position. The two arrays `mouse_button_down` and `mouse_button_clicked` is to distinguish between 'a mouse button is clicked' and 'a mouse button is being pressed for a while'. Interestingly, the cursor position is initialized to be `(0, 0)`, which accounts for the angle of the default enemy's tank turret because the enemy cannot receive any more inputs.

All the keys available have names `GLFW_KEY_*` or `GLFW_MOUSE_*`. For example, in `tiny_tank.cpp`, the codes
```c++
void Tank::TankMove(float move_speed, float rotate_angular_speed) {
  auto player = game_core_->GetPlayer(player_id_);
  if (player) {
    auto &input_data = player->GetInputData();
    glm::vec2 offset{0.0f};
    if (input_data.key_down[GLFW_KEY_W]) {
      offset.y += 1.0f;
    }
    if (input_data.key_down[GLFW_KEY_S]) {
      offset.y -= 1.0f;
    }
    ...
    float rotation_offset = 0.0f;
    if (input_data.key_down[GLFW_KEY_A]) {
      rotation_offset += 1.0f;
    }
    if (input_data.key_down[GLFW_KEY_D]) {
      rotation_offset -= 1.0f;
    }
  }
}
```
basically show that pressing `W` and `S` moves the tank, while pressing `A` and `D` rotates the tank.

### Rendering

If you need to draw something on the screen, you need to use
```c++
auto mgr = AssetsManager::GetInstance();
your_model_index = mgr->RegisterModel({vertices}, {indices});
```
to first 'register' your model in `AssetsManager`, then use
```c++
battle_game::SetTransformation(position, rotation, scale);
battle_game::SetTexture(texture_id);
battle_game::SetColor(color);
battle_game::DrawModel(your_model_index);
```
to draw the model. The `SetTransformation` can be divided into `SetPosition` and `SetRotation` if you only need one of those, which basically sets the direction of the model you are going to draw.

The vertices correspond to the actual coordinates of the vertices of the polygon you want to draw. The indices is packed into groups of three, each one representing a triangle. Using tiny tank as an example, 
```c++
Tank::Tank(GameCore *game_core, uint32_t id, uint32_t player_id)
    : Unit(game_core, id, player_id) {
  if (!~tank_body_model_index) {
    auto mgr = AssetsManager::GetInstance();
    {
      /* Tank Body */
      tank_body_model_index = mgr->RegisterModel(
          {
              {{-0.8f, 0.8f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
              {{-0.8f, -1.0f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
              {{0.8f, 0.8f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
              {{0.8f, -1.0f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
              // distinguish front and back
              {{0.6f, 1.0f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
              {{-0.6f, 1.0f}, {0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f}},
          },
          {0, 1, 2, 1, 2, 3, 0, 2, 5, 2, 4, 5});
    }
    ...
  }
}
```
The tank body has six indices: 
```
1 (-0.8, 0.8)
2 (-0.8, -1.0)
3 (0.8, 0.8)
4 (0.8, -1.0)
5 (0.6, 1.0)
6 (-0.6, 1.0)
```
and the indices indicates that we should draw the triangles 012, 123, 025, 245. One can check that this indeed gives the tank body.

For the tank turret (or more generally anything round), you need to specify a precision and use polygons to approximate it. Check out how the tank turret is drawn for yourself.

If you want to use pictures, typically for bullets, use
```c++
battle_game::SetTexture("file_location");
battle_game::DrawModel(0);
```

## Settings

The settings of a unit include its speed, angular speed, fire interval, health, and damage its bullet causes (which is implemented in `bullet.h`). Each of them consists of two parts: the basic value and the scale. If you want a bullet to change some unit's speed, for example, change the unit's speed scale upon impact but not its basic speed.
